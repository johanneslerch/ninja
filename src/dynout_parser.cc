/* Generated by re2c 1.3 */
// Copyright 2011 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "dynout_parser.h"

#include "debug_flags.h"
#include "metrics.h"

#include <errno.h>

using namespace std;

namespace {

size_t find_newline(const string& str, size_t pos) {
    for (size_t i = pos; i < str.size(); i++) {
      if (str[i] == '\r' || str[i] == '\n') {
        return i;
      }
    }
    return std::string::npos;
}

}
bool DynoutParser::Parse(State* state, DiskInterface* disk_interface,
            Edge* edge, const std::string& path, 
            std::vector<Node*>* nodes, int* outputs_count,
            std::string* err) {
METRIC_RECORD("dynout load");
  // Read depfile content.  Treat a missing depfile as empty.
  string content;
  switch (disk_interface->ReadFile(path, &content, err)) {
  case DiskInterface::Okay:
    break;
  case DiskInterface::NotFound:
    err->clear();
    break;
  case DiskInterface::OtherError:
    *err = "loading '" + path + "': " + *err;
    return false;
  }
  if (content.empty()) {
    return true;
  }

  vector<string> output_paths;
  int start_size = nodes->size();

  size_t pos = 0;
  size_t next = find_newline(content, pos);
  while (next != std::string::npos) {
    if (next > pos) {
      output_paths.push_back(content.substr(pos, next - pos));
    }
    pos = next + 1;
    next = find_newline(content, pos);
  }
  if (pos < content.size() - 1) {
    output_paths.push_back(content.substr(pos));
  }

  if (output_paths.empty()) {
    *err = path + ": no implicit outputs declared";
    return false;
  }

  vector<Node*> new_implicit_outputs;

  new_implicit_outputs.reserve(output_paths.size());
  for (vector<string>::iterator i = output_paths.begin(); i != output_paths.end(); ++i) {
    string p = *i;
    uint64_t slash_bits;
    CanonicalizePath(&p, &slash_bits);
    Node* new_node = state->GetNode(p, slash_bits);
    nodes->push_back(new_node);
    bool exist = false;
    for (vector<Node*>::iterator n = edge->outputs_.begin(); n != edge->outputs_.end(); n++) {
      if (*n == new_node) {
        exist = true;
        break;
      }
    }
    if (!exist) {
      new_implicit_outputs.push_back(new_node);
    }
  }
  *outputs_count = (int) nodes->size() - start_size;

    // Add the dyndep-discovered outputs to the edge.
  edge->outputs_.insert(edge->outputs_.end(),
                        new_implicit_outputs.begin(),
                        new_implicit_outputs.end());
  edge->implicit_outs_ += new_implicit_outputs.size();

  // Add this edge as incoming to each new output.
  for (std::vector<Node*>::const_iterator i =
           new_implicit_outputs.begin();
       i != new_implicit_outputs.end(); ++i) {
    if (Edge* old_in_edge = (*i)->in_edge()) {
      // This node already has an edge producing it.  Fail with an error
      // unless the edge was generated by ImplicitDepLoader, in which
      // case we can replace it with the now-known real producer.
      if (!old_in_edge->generated_by_dep_loader_) {
        *err = "multiple rules generate " + (*i)->path() +" via rules " + edge->rule_->name() + " and " + old_in_edge->rule_->name() + ":\n\t" 
            + edge->to_string() + "\n\t" + old_in_edge->to_string();
        return false;
      }
      old_in_edge->outputs_.clear();
    }
    (*i)->set_in_edge(edge);
  }

  
  if (!g_keep_dynout) {
    if (disk_interface->RemoveFile(path) < 0) {
      *err = string("deleting dynout: ") + strerror(errno) + string("\n");
      return false;
    }
  }
  return true;
}
