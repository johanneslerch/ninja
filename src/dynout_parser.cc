/* Generated by re2c 1.3 */
// Copyright 2011 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "dynout_parser.h"

#include "debug_flags.h"
#include "metrics.h"

using namespace std;

namespace {

size_t find_newline(const string& str, size_t pos) {
    for (size_t i = pos; i < str.size(); i++) {
      if (str[i] == '\r' || str[i] == '\n') {
        return i;
      }
    }
    return std::string::npos;
}

}
bool DynoutParser::Parse(State* state, DiskInterface* disk_interface,
            Edge* edge, const std::string& path, 
            std::vector<Node*>* nodes, int* outputs_count,
            std::string* err) {
METRIC_RECORD("dynout load");
  // Read depfile content.  Treat a missing depfile as empty.
  string content;
  switch (disk_interface->ReadFile(path, &content, err)) {
  case DiskInterface::Okay:
    break;
  case DiskInterface::NotFound:
    err->clear();
    break;
  case DiskInterface::OtherError:
    *err = "loading '" + path + "': " + *err;
    return false;
  }
  // On a missing depfile: return false and empty *err.
  if (content.empty()) {
    EXPLAIN("dynout '%s' is missing", path.c_str());
    return false;
  }

  vector<string> output_paths;

  size_t pos = 0;
  size_t next = find_newline(content, pos);
  while (next != std::string::npos) {
    if (next > pos) {
      output_paths.push_back(content.substr(pos, next));
    }
    pos = next + 1;
    next = find_newline(content, pos);
  }
  if (pos < content.size() - 1) {
    output_paths.push_back(content.substr(pos));
  }

  if (output_paths.empty()) {
    *err = path + ": no implicit outputs declared";
    return false;
  }

  vector<Node*> implicit_outputs;

  implicit_outputs.reserve(output_paths.size());
  for (vector<string>::iterator i = output_paths.begin(); i != output_paths.end(); ++i) {
    string p = *i;
    string p_err;
    uint64_t slash_bits;
    if (!CanonicalizePath(&p, &slash_bits, &p_err)) {
      *err = path + ": " + p_err;
      return false;
    }
    Node* new_node = state->GetNode(p, slash_bits);
    bool exist = false;
    for (vector<Node*>::iterator n = edge->outputs_.begin(); n != edge->outputs_.end(); n++) {
      if (*n == new_node) {
        exist = true;
        break;
      }
    }
    if (!exist) {
      if (!new_node->StatIfNecessary(disk_interface, err)) {
        return false;
      }
      implicit_outputs.push_back(new_node);
    }
  }

    // Add the dyndep-discovered outputs to the edge.
  edge->outputs_.insert(edge->outputs_.end(),
                        implicit_outputs.begin(),
                        implicit_outputs.end());
  edge->implicit_outs_ += implicit_outputs.size();

  // Add this edge as incoming to each new output.
  for (std::vector<Node*>::const_iterator i =
           implicit_outputs.begin();
       i != implicit_outputs.end(); ++i) {
    if (Edge* old_in_edge = (*i)->in_edge()) {
      // This node already has an edge producing it.  Fail with an error
      // unless the edge was generated by ImplicitDepLoader, in which
      // case we can replace it with the now-known real producer.
      if (!old_in_edge->generated_by_dep_loader_) {
        *err = "multiple rules generate " + (*i)->path();
        return false;
      }
      old_in_edge->outputs_.clear();
    }
    (*i)->set_in_edge(edge);
  }

  nodes->insert(nodes->end(), implicit_outputs.begin(), implicit_outputs.end());
  *outputs_count = (int) implicit_outputs.size();
  return true;
}